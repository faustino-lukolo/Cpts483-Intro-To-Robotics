<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: now Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">now Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<hr/>Source file:<ul>
<li><a href='https://github.com/qwertie/Loyc/blob/master/Src/Loyc.Syntax/Nodes/LNode.cs'>/Src/Loyc.Syntax/Nodes/LNode.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>the @ sign) and #struct quite differently, as <code>#struct</code> is treated like a keyword and <code>struct</code> is not. </p>
<p>Since the "#" character is already reserved in plain C# for preprocessor directives, any node name such as "#if" and "#else" that could be mistaken for an old-fashioned preprocessor directive must be preceded by "@" at the beginning of a line. For example, the statement "if (failed) return;" can be represented in prefix notation as "@#if(failed, return)", although the node name of "@#if" is actually "#if" (while the node name of the preprocessor directive "#if" would be "##if", and the node name of "return" is actually "#return"). Please note that preprocessor directives themselves are not part of the normal syntax tree, because they can appear midstatement. For example, this is valid C#: </p><pre>
if (condition1
   #if DEBUG
      &amp;&amp; condition2
   #endif
   ) return;
</pre><p> Preprocessor statements will be processed early in the compiler and then deleted. </p>
<p>The special #X tokens don't require an argument list, although the compiler expects most of them to have one (and often it must have a specific length). Again, this doesn't matter for parsing, only for later stages of analysis. </p>
<p>Any statement or expression can have attributes attached to it; when attributes are seen beside a statement, they are attached to the root node of that statement. In this example, the attribute is attached to the = operator: </p><pre>
[PointlessAttribute(true)] x = y * 2;
</pre><p> Attributes are allowed not just at the beginning of a statement, but at the beginning of any subexpression in parenthesis: </p><pre>
Debug.Assert(x == ([PointlessAttribute(true)] y + 2));
</pre><p> Here, the PointlessAttribute is attached to the addition operator (+). These attributes are simply normal EC# nodes (arbitrary expressions), so they don't have to look like normal attributes: </p><pre>
[TheKing is dead] LongLive(TheKing);
</pre><p> Applying attributes to executable statements has no predefined meaning; A warning is issued if the compiler encounters an attribute where one is not allowed in plain C#, or if the syntax cannot be interpreted as an attribute. The parser supports this feature because it is sometimes useful in metaprogramming and DSLs. </p>
<p>Because an attribute must be attached to something, an "assembly:" attribute is represented as an #assembly node with an attribute attached: </p><pre>
[assembly: AssemblyTitle("MyApp")]  // Normal EC#
[AssemblyTitle("MyApp")] #assembly; // The way EC# sees it internally
</pre><p> (assembly and module attributes must be special-cased anyway, since it doesn't make sense for them to be attached to whatever follows them.) </p>
<p>Unlike in plain C#, by the way, EC# labels do not have to be attached to anything; they are considered statements by themselves: </p><pre>
void f() {
   goto end;
   end:       // OK in EC#, syntax error in plain C#
}
</pre><p> Perhaps the most interesting thing about EC# is that it is actually an expression-based language, like LISP: everything in EC# can be considered an expression! For example, instead of writing a method as a list of statements, we can write it as a list of expressions: </p><pre>
// Normal EC#
public static char HexDigitChar(int value)
{
    Debug.Assert(16u &gt; (uint)value);
    if ((uint)value &gt;= 10)
        return (char)('A' - 10 + value);
    else
        return (char)('0' + value);
}
// Bizarro EC#
[#public, #static] #def(HexDigitChar, #(#var(int, value)), #char, #
(
    Debug.Assert(16u &gt; (uint)value),
    #if ((uint)value &gt;= 10,
        #return((char)('A' - 10 + value)),
        #return((char)('0' + value)));
);
</pre><p> Just so we're clear, you're not supposed to write "bizarro" code, but this notation can help you understand the underlying representation. The parser basically operates in two modes, one for expressions and one for statements. Statement mode allows certain constructs like "if", "while" and "class" that expression mode does not understand. But once parsing is finished, the code is just a tree of nodes with almost nothing to distinguish statements from expressions. </p>
<p>EC# adopts a convention from LISP: the value of the final statement in a block is the value of the block as a whole. This can be used to simplify method and property definitions: </p>
<p>int _value; public int Value { get { _value } } </p>
<p>The EC# if-else and switch statements (but not loops) work the same way, and you can put a braced block in the middle of any expression: </p><pre>
int hexChar = {
        if ((uint)value &gt;= 10)
            'A' - 10
        else
            '0'
    } + value;
</pre><p> The braced block is represented by a {} node, which introduces a new scope. In contrast, the special # node type (the "list marker"), does not create a new scope. It is normally used with expression syntax: </p><pre>
var three = #(Console.WriteLine("Fetching the three!"), 3);
var eight = #(int x = 5, three + x);
var seven = x + 2;
</pre><p> Since # does not create a new scope, the variable "x" is created in the outer scope, where it can be used to compute the value of seven. The # keyword is intended mostly to express lists with prefix notation, but it can be used with braces in case there is a need to switch back to statement notation. </p>
<p>The above code is a bit confusing because of how it is written; EC# is meant for mature people who have enough sense not to write confusing code like this.</p>
<h3>The reimplementation</h3>
<p>This implementation has been redesigned (in Subversion, the last version based on the old design is revision 289.) The core concept is the same as described in my blog at <a href="http://loyc-etc.blogspot.ca/2013/04/the-loyc-tree-and-prefix-notation-in-ec.html">http://loyc-etc.blogspot.ca/2013/04/the-loyc-tree-and-prefix-notation-in-ec.html</a> except that the concept of a "Head" has mostly been eliminated, although you might see it occasionally because it still has a meaning. The "head" of a node refers either to the Name of a symbol, the Value of a literal, or the Target of a call (i.e. the name of the method being called, which could be an arbitrarily complex node). In the original implementation, it was also possible to have a complex head (a head that is itself a node) even when the node was not a call; this situation was used to represent an expression in parenthesis. </p>
<p>This didn't quite feel right, so I changed it. Now, only calls can be complex, and the head of a call (the method being called) is called the Target. </p>
<p>In the new version, there are explicitly three types of nodes: symbols, literals, and calls. There is no longer a Head property, instead there are three separate properties for the three kinds of heads, Name (a Symbol), Value (an Object), and Target (an LNode). Only call nodes have a Target, and only literal nodes have a Value (as an optimization, StdTriviaNode breaks this rule; it can only do this because it represents special attributes that are outside the normal syntax tree, such as comments). Symbol nodes have a Name, but I thought it would be useful for some call nodes to also have a Name, which is defined as the name of the Target if the Target is a symbol (if the Target is not a symbol, the Name must be blank.) </p>
<p>An expression in parenthesis is now represented by a call with a blank name (use IsParenthesizedExpr to detect this case; it is incorrect to test <code>Name == $``</code> because a call with a non-symbol Target also has a blank name.) </p>
<p>The following differences in implementation have been made: </p><ul>
<li>
"Red" and "green" nodes have basically been eliminated, at least for now. </li>
<li>
Nodes normally do not contain parent references anymore </li>
<li>
Mutable nodes have been eliminated, for now. </li>
<li>
There are now three standard subclasses, IdNode, LiteralNode and CallNode, and a node can no longer change between classes after it is created. </li>
<li>
An empty Name is now allowed. A literal now has a blank name (instead of #literal) and a method that calls anything other than a simple symbol will also have a blank Name. Note: The Name property will still never return null. </li>
<li>
As mentioned, an expression in parenthesis is represented differently. </li>
</ul>
<p>The problems that motivated a redesign are described at <a href="http://loyc-etc.blogspot.ca/2013/05/redesigning-loyc-tree-code.html">http://loyc-etc.blogspot.ca/2013/05/redesigning-loyc-tree-code.html</a> </p>
<p>One very common use of mutable nodes is building lists of statements, e.g. you might create an empty braced block or an empty loop and then add statements to the body of the block or loop. To do this without mutable nodes, create a mutable RWList{LNode} instead and add statements there; once the list is finished, create the braced block or loop afterward. The new design stores arguments and attributes in RVList{LNode} objects; you can instantly convert your WList to a VList by calling RWList{LNode}.ToRVList(). </p>
<p>During the redesign I've decided on some small changes to the representation of certain expressions in EC#. </p><ul>
<li>
The '.' operator is now treated more like a normal binary operator; <code>a.b.c</code> is now represented <code>#.(#.(a, b), c)</code> rather than <code>#.(a, b, c)</code> mainly because it's easier that way, and because the second representation doesn't buy anything significant other than a need for special-casing. </li>
<li>
<code>int x = 0</code> will now be represented <code>#var(int, x = 0)</code> rather than <code>#var(int, x(0))</code>. I chose the latter representation initially because it is slightly more convenient, because you can always learn the name of the declared variable by calling <code>var.Args[1].Name</code>. However, I decided that it was more important for the syntax tree to be predictable, with obvious connections between normal and prefix notations. Since I decided that <code>alias X = Y;</code> was to be represented <code>#alias(X = Y, #())</code>, it made sense for the syntax tree of a variable declaration to also resemble its C# syntax. There's another small reason: C++ has both styles <code>Foo x(y)</code> and <code>Foo x = y</code>; if <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> were to ever support C++, it would make sense to use <code>#var(Foo, x(y))</code> and <code>#var(Foo, x = y)</code> for these two cases, and I believe C#'s variable declarations are semantically closer to the latter. (Note: another possibility was #var(int, x) = 0, but I decided this wasn't an improvement, it would just shift the pain around.) </li>
<li>
An constructor argument list is required on <em>all</em> types using the #new operator, e.g. <code>new int[] { x }</code> must have an empty set of arguments on int[], i.e. <code>#new(#of(#[],int)(), x)</code>; this rule makes the different kinds of new expressions easier to interpret by making them consistent with each other. </li>
<li>
A missing syntax element is now represented by an empty symbol instead of the symbol #missing. </li>
<li>
I've decided to adopt the "in-expression" generics syntax from Nemerle as an unambiguous alternative to angle brackets: List.[int] means List&lt;int&gt; and the printer will use this syntax in cases where angle brackets are ambiguous. </li>
<li>
By popular demand, constructors will be written this(...) instead of new(...), since both D and Nemerle use the latter notation. </li>
<li>
The \ and $ characters have been swapped;  now denotes a symbol S, while $S now denotes a substitution. </li>
<li>
The \ and $ characters have been swapped;  now denotes a symbol S, while $S now denotes a substitution. Originally EC# was designed just as an extension of C#, so \ made sense as a substitution operator for string interpolation because it doesn't hurt backward compatibility: "Loaded '\(filename)' successfully". But now that my focus has shifted to multi-language interoperability, $ makes more sense, as it is used for string interpolation in at least five other languages and it makes sense to use the same character for both string substitution and code substitution. </li>
</ul>
<h3>Important properties</h3>
<p>The main properties of a node are </p><ol>
<li>
Attrs: holds the attributes of the node, if any. </li>
<li>
Name: the name of an IdNode, or the name of the IdNode that is acting as the Target of a CallNode. </li>
<li>
Value: the value of a LiteralNode. </li>
<li>
Target: the target of a CallNode. It represents a method, macro, or special identifier that is being called. </li>
<li>
Args: holds the arguments to a CallNode, if any. Returns an empty list if the node does not have an argument list. </li>
<li>
Range: indicates the source file that the node came from and location in that source file. </li>
<li>
Style: an 8-bit flag value that is used as a hint to the node printer about how the node should be printed. For example, a hex literal like 0x10 has the NodeStyle.Alternate style to distinguish it from decimal literals such as 16. Custom display styles that do not fit in the Style property can be expressed with attributes. </li>
</ol>
<p>The argument and attribute lists cannot be null, since they have type RVList{Node} which is a struct. </p>
<p><code>LNode</code> implements INegListSource{T}, so you can loop through all children of the node like this: <code> for (int i = node.Min; i &lt;= node.Max; i++) { LNode child = node[i]; } </code> You can also use <code>foreach</code>. The children are numbered like this: </p><ul>
<li>
if i is less than -1, node[i] refers to an attribute. Specifically, node[i] means node.Attrs[i + node.Attrs.Count + 1] in that case. </li>
<li>
node[-1] refers to <code>Target</code> (but throws if there is no target) </li>
<li>
Non-negative values are indexes of Args, e.g. node[i] means node.Args[i]. </li>
</ul>
<p>LNode also provides <code>Select(child =&gt; result)</code> and <code>ReplaceRecursive(child =&gt; result)</code> methods which allows you to transform all children (Atrrs, Target and Args). Currently there is no <code>Where(child =&gt; bool)</code> method because it is not possible to remove the Target of an LNode (you can still use standard LINQ Where(), of course, but the result is not an LNode).</p>
<h3>Note</h3>
<p>The argument and attribute lists should never contain null nodes. Any code that puts nulls in Args or Attrs is buggy. However, we can't ensure nulls are not placed into RVList{T} since it's a general-purpose data type, not specialized for LNode. There is code to ensure nulls are not placed in Args and Attrs (NoNulls), but only in debug builds, since null-checking is fairly expensive. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 10 2014 15:33:20 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
