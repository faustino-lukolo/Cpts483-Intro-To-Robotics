<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: are Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">are Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>All nodes in a <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> syntax tree share this base class. 
 <a href="classare.html#details">More...</a></p>
<hr/>Source file:<ul>
<li><a href='https://github.com/qwertie/Loyc/blob/master/Src/Loyc.Syntax/Nodes/LNode.cs'>/Src/Loyc.Syntax/Nodes/LNode.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>All nodes in a <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> syntax tree share this base class.</p>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> defines only three types of nodes: simple symbols, literals, and calls. </p><ul>
<li>
A IdNode is a simple identifier, such as a VariableName </li>
<li>
A LiteralNode is a literal constant, such as 123 or "hello" </li>
<li>
A CallNode encompasses all other kinds of nodes, such as normal function calls like <code>f(x)</code>, generic specifications like <code>f&lt;x&gt;</code> (represented <code>#of(f, x)</code>), braced blocks of statements (represented <code>&lt;tt&gt;{}</code>(stmt1, stmt2, ...)), and so on. Also, parenthesized expressions are represented as a call with one argument and <code>null</code> as the Target. </li>
</ul>
<p>This class provides access to all properties of all three types of nodes, in order to make this class easier to access from plain C#, and to avoid unnecessary downcasting in some cases. </p>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes are typically immutable, except for the 8-bit Style property which normally affects printing only. If a node allows editing of any other properties, IsFrozen returns false. </p>
<h3>Background information</h3>
<p>EC# (enhanced C#) is intended to be the starting point of the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> (Language of your choice) project, which will be a family of programming languages that will share a common representation for the syntax tree and other compiler-related data structures. </p>
<p>Just as LLVM assembly has emerged as a nearly universal standard intermediate representation for back-ends, <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes are intended to be a universal intermediate representation for syntax trees, and <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> will (eventually) include a generic set of tools for semantic analysis so that it provides a generic representation for front-ends. </p>
<p>EC#, then, will be the first language to use the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> syntax tree representation, known as the "Loyc tree" for short. Most syntax trees are very strongly typed, with separate data types for, say, variable declarations, binary operators, method calls, method declarations, unary operators, and so forth. <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a>, however, defines only three types of Nodes, and this one class provides access to all the parts of a node. There are several reasons for this design: </p><ul>
<li>
Simplicity. Many projects have thousands of lines of code dedicated to the AST (abstract syntax tree) data structure itself, because each kind of AST node has its own class. </li>
<li>
Serializability. <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes can always be serialized to a plain text "prefix tree" and deserialized back to objects, even by programs that are not designed to handle the language that the tree represents*. This makes it easy to visualize syntax trees or exchange them between programs. </li>
<li>
Extensibility. <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes can represent any language imaginable, and they are suitable for embedded DSLs (domain-specific languages). Since nodes do not enforce a particular structure, they can be used in different ways than originally envisioned. For example, most languages only have "+" as a binary operator, that is, with two arguments. If <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> had a separate class for each AST, there would probably be a PlusOperator class derived from BinaryOperator, or something, with properties "Left" and "Right". But since there is only one node class, a "+" operator with three arguments is always possible; this is denoted by #+(a, b, c) in EC# source code. </li>
</ul>
<ul>
<li>Currently, the only supported syntax for plain-text <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees is EC# syntax, either normal EC# or prefix-tree notation. As <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> grows in popularity, a more universal syntax should be standardized. </li>
</ul>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees are comparable to LISP trees, except that "attributes" and position information are added to the tree, and the concept of a "list" is replaced with the concept of a "call", which I feel is a more intuitive notion in most programming languages that are not LISP. </p>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a>'s representation is both an blessing and a curse. The advantage is that <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes can be used for almost any purpose, perhaps even representing data instead of code in some cases. However, there is no guarantee that a given AST follows the structure prescribed by a particular programming language, unless a special validation step is performed after parsing. In this way, <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees are similar to XML trees, only simpler. </p>
<p>Another major disadvantage is that it is more difficult to interpret a syntax tree correctly: you have to remember that a method definition has the structure <code>#def(return_type, name, args, body)</code>, so if "node" is a method definition then <code>node.Args[2]</code> represents the return type, for example. In contrast, most compilers have an AST class called <code>MethodDefinition</code> or something, that provides properties such as Name and ReturnType. Once EC# is developed, however, aliases could help avoid this problem by providing a more friendly veneer over the raw nodes. </p>
<p>For optimization purposes, the node class is a class hierarchy, but most users should only use this class and perhaps the three derived classes IdNode, LiteralNode and CallNode. Some users will also find it useful to use LNodeFactory for generating synthetic code snippets (bits of code that never existed in any source file), although you can also use the methods defined here in this class: Id(), Literal(), Call(), InParens(). </p>
<p>Normal LNodes are "persistent" in the comp-sci sense, which means that a subtree can be shared among multiple syntax trees, and nodes do not know their own parents. This allows a single node to exist at multiple locations in a syntax tree. This makes manipulation of trees convenient, as there is no need to "detach" a node from one place, or duplicate it, before it can be inserted in another place. Immutable nodes can be safely re-used within different source files or multiple versions of one source file in an IDE's "intellisense" or "code completion" engine.</p>
<h3><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> and EC#</h3>
<p>Now let's talk about EC# syntax and how it relates to this class. </p>
<p>EC# supports a generalized C-style syntax which will be described briefly here. Basically, almost any code that a programming student might mistake for real C# code is legal, and there is some odd-looking syntax you've never seen before that is also legal. </p>
<p>Also, virtually any tree of nodes can be represented in EC# source code using a prefix notation, which helps you understand <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> ASTs because the prefix notation closely corresponds to the AST. For example, @=(x, @*(y, 2)) is equivalent to the expression x = y * 2. This notation tells you that</p><ul>
<li>there are two nodes with two arguments each,</li>
<li>the outer one is named "=" and the inner is named "*" The syntax tree built from these two representations is identical. </li>
</ul>
<p>Prefix notation can be freely mixed with normal EC# code, although usually there is no reason to do so: </p>
<p>public Point OneTwo = MakePoint(1, 2); public #var(Point, Origin(MakePoint(0, 0))); public static #def(MakePoint, #(int x, int y), System.Drawing.Point, #{ return new Point(x, y); }); </p>
<p>The prefix notation often involves special identifiers of the form #X, where X is an identifier (or keyword). In the LES and EC# parsers, the # character is considered a normal part of an identifier, no different than a letter (A-Z) or an underscore (_). However, the # is "special" in the sense that when a special construct (like a method, or a field declaration) is converted to a <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> tree, the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> tree represents that special construct using an identifier that starts with "#". </p>
<p>Code in prefix notation also often has identifiers of the form , where X is </p><ol>
<li>
An operator such as + or == </li>
<li>
A C# keyword </li>
<li>
A backquoted string </li>
</ol>
<p>The @ character is <em>not</em> part of the identifier; it merely indicates that the characters after the @ symbol represent an identifier, rather than an operator or keyword. For example, "==" is normally an operator, and "class" is normally a keyword, but @== and, not operators or keywords. </p>
<p>The following examples show how source code text is translated into symbol names: </p><pre>
#foo     ==&gt; "#foo"        &gt;&gt;           ==&gt; "&gt;&gt;"
#?       ==&gt; "?"           @`{}`         ==&gt; "{}"
#while   ==&gt; "#while"      @`#Newline<br />
` ==&gt; "#Newline\n"
#while  ==&gt; "#while"      @`hi there!`  ==&gt; "hi there!"
   ==&gt; "while"
</pre><p> Identifiers that start with # are parsed like normal identifiers, but are reserved for things that have special semantic meaning. For example, "#class" is treated by the parser like any other identifier, but it has the same semantic meaning as "class", although a structure defined with "#class" looks quite different from the same structure defined using "class". For example, the following forms are equivalent: </p><pre>
#class(X, #(), @`{}`(int x));
class X { int x; }
</pre><p> The #class(...) form uses prefix notation, and it demonstrates the structure of the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> tree for a class declaration. </p>
<p>As another example, "#return(7);" is syntactically a function call to a function called "#return". Although the parser treats it like a function call, it produces the same syntax tree as "return 7;" does. </p>
<p>Ordinary method calls like <code>Foo(x, y)</code> count as prefix notation, and in EC# there is actually a non-prefix notation for this call: <code>x <code>Foo</code> y</code>. Both forms are equivalent, but the infix notation can only be used when you are calling a method that takes two arguments (also, the string <code>Foo</code> should be a simple identifier; if it contains a dot, it is treated as part of the identifier name, not as a normal dot operator.) </p>
<p>So #class is a keyword that is parsed like an identifier, but this is different from the notation </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 10 2014 15:33:20 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
