---
title: The List Trifecta, part 2
layout: article
tagline: Sorted data structures to meet your needs 
---
<h2>Introduction</h2>

<p>In the <a href="http://www.codeproject.com/Articles/568095/The-List-Trifecta-Part-1">previous article</a> I introduced the <strong>A-List</strong>, an &quot;all-purpose&quot; list, which is a cross between a conventional List&lt;T&gt; and an in-memory <a href="http://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a>. It also has some interesting features like combining or splitting two large lists in O(log N) time, freezing, fast cloning, and observability.  </p>

<p>In this article I'll talk about the sorted &quot;B&quot; data structures based on the A-List concept: The <code>BList&lt;T&gt;</code>,  the <code>BDictionary&lt;K,V&gt;</code> and the <code>BMultiMap&lt;K,V&gt;</code>. Here's a class diagram--similar to the diagram in the last article, but with different derived classes:</p>

<p><img height="811" src="BListsDiagram.png" width="691" /></p>

<p>As I said in the first article, data structures in the A-List family (which includes <code>BDictionary</code>, <code>BList</code> and <code>BMultiMap</code>) are tree data structures similar to B+ tree, with one unusual feature: they are indexable; you can write <code>alist[index]</code> (to see how this works, it may help to look at the diagrams in the previous article.)</p>

<p>Growing up as a young software developer, I used a lot of indexed lists and growable arrays all over the place, and occasionally they got very slow when you inserted lots of elements in the middle, or at the beginning, of a long list. In comp-sci speak, building a list of elements, when inserting at random locations, takes O(n<sup>2</sup>) time, which means it's really damn slow for large <code>n</code>! A-List data structures don't have that problem; they are never slow. They do have higher <em>constant overhead</em> than <code>List&lt;T&gt;</code>, but they don't slow down very much as the list gets bigger.  </p>

<p>The basic indexing functionality and management of the tree structure is implemented in the base classes <code>AListBase&lt;T&gt;</code>, <code>AListNode&lt;K,T&gt;</code>, <code>AListInnerBase&lt;K,T&gt;</code> and <code>AListLeaf&lt;K,T&gt;</code>. The new derived classes on the diagram (the ones that start with &quot;B&quot;) provide and enforce a constraint that the data must be sorted. </p>

<p> </p>

<h2>BDictionary: B is for Better   </h2>

<p>The .NET framework has a class called <code><a href="http://msdn.microsoft.com/en-us/library/ms132319.aspx">SortedList&lt;TKey,TValue&gt;</a></code>. <em>You should never, ever use that class to build a sorted list!</em> Unless, that is, the data was already sorted to start with, in which case you still don't need <code>SortedList</code>.  </p>

<p>The problem with <code>SortedList</code> is, of course, performance. It takes O(n<sup>2</sup>) time to build a <code>SortedList</code> from <code>n</code> key-value pairs in random order.  Instead, you should use <a href="http://msdn.microsoft.com/en-us/library/f7fta44c.aspx"><code>SortedDictionary&lt;TKey,TValue&gt;</code></a> or <code>BDictionary&lt;K,V&gt;</code>, depending on whether you need <code>BDictionary</code>'s numerous features or not.</p>

<p><code>BDictionary&lt;K,V&gt;</code> is very much like <code>SortedList</code>, just much faster, and with a heck of a lot more features. Like <span style="color: rgb(153, 0, 0); font-family: Consolas,'Courier New',Courier,mono; font-size: 15px;">SortedList</span>, <code>BDictionary</code> is a dictionary of items kept in sorted order, and it allows access to items by index. It is efficient for all operations: <code>Add</code>, <code>Remove</code>, <code>IndexOf</code>, <code>ContainsKey</code>, <code>FindLowerBound</code>, <code>FindUpperBound</code>, and the indexer all run in O(log N) time. You can specify a key-comparison delegate when you construct it, so the type <code>K</code> does not have to be directly sortable and you don't have to sort in the &quot;natural order&quot; for <code>T</code>.  </p>

<p>It also supports the following operations that <code>SortedList</code> does not: </p>

<p> </p>

<ul>
	<li><code>FindLowerBound(k)</code>: Finds the lowest index of an item whose key that is equal to or greater than <code>k</code>. It behaves like the standard C++ function <a href="http://www.cplusplus.com/reference/algorithm/lower_bound/">lower_bound</a>.  </li>
	<li><code>FindUpperBound(k)</code>: Finds the index of the first item in the list that is greater than <code>k</code> (this tends to be less useful than <code>FindLowerBound</code>.)  </li>
	<li><code>AddRange(list)</code>, <code>RemoveRange(list)</code>, <code>RemoveRange(start, count)</code> </li>
	<li><code>this[key, defaultValue]</code>: finds the value associated with a key. If that key is not found, returns <code>defaultValue</code>. </li>
	<li><code>Clone()</code>: creates a copy in O(1) time (this technique is explained in the part 1) </li>
	<li><code>CopySection</code>, <code>RemoveSection</code> : duplicates or removes any portion of the list in O(log N) time.</li>
	<li><code>AddIfNotPresent(k, v)</code>: Adds the specified pair only if the key is not already present in the dictionary.</li>
	<li><code>ReplaceIfPresent(k, v)</code>: Replaces the value associated with k, if it already exists in the dictionary. </li>
	<li><code>SetAndGetOldValue(k, ref v)</code>: Gets the old value associated with <code>k</code>, if there is one, then sets <code>this[k] = v</code>.  </li>
</ul>

<p>And, like all classes derived from <code>AListBase</code>, <code>BDictionary</code> (and <code>BList</code> and <code>BMultiMap</code>) supports <code>RemoveAll(lambda)</code>, fast <code>Clone()</code>, <code>Freeze()</code>, <code>Slice()</code>, <code>ReverseView</code> and the <code>ListChanging</code> event.</p>

<h4>Spot the design flaw?  </h4>

<p><code>BDictionary&lt;K,V&gt;</code> will give you a small problem if <code>K</code> just happens to be <code>int</code>, because there is a <code>this[K]</code> indexer and also a <code>this[int]</code> indexer. So if you call <code>dict[4]</code>, does that get the fifth element (of type <code>KeyValuePair&lt;K,V&gt;</code>), or the <code>V</code> value associated with the key <code>4</code>? Well, the two indexers exist in different classes: <code>this[K]</code> is in the derived class, and <code>this[int]</code> is in the base class. So <code>dict[4]</code> will get the <code>V</code> value associated with the key <code>4</code>, and you can get the fifth element with an upcast: <code>((AListBase&lt;int,KeyValuePair&lt;int,V&gt;&gt;) dict)[4]</code>. Okay, it's a bit clunky, but it works.</p>

<p> </p>

<h2>BList and BDictionary: I lied. B is for B+ tree.  </h2>

<p><code>BList&lt;T&gt;</code> is simply a sorted list (like all other A-List classes, it is structured as a B+ tree). Unlike <code><a href="http://msdn.microsoft.com/en-us/library/ms132319.aspx">SortedList&lt;TKey,TValue&gt;</a> </code>and <code>BDictionary</code>, it is just a list, not a dictionary. <code>BList</code> permits duplicate items, so it is not a &quot;set&quot; class. It allows you to specify a comparison delegate when you construct it, so the type <code>T</code> does not have to be directly sortable and you don't have to sort in the &quot;natural order&quot; for <code>T</code>.</p>

<p><code>BList</code> has all the same features of <code>BDictionary</code>, just without that pesky distinction between &quot;keys&quot; and &quot;values&quot;. There's not much else to say about <code>BList</code>, so let's move on...</p>

<p><code>BMultiMap&lt;K,V&gt;</code>, derived from <code>BList&lt;KeyValuePair&lt;K,V&gt;&gt;</code>, is a special kind of dictionary that permits duplicate keys (as well as duplicate values). Or, viewed from a different perspective, it allows multiple values to be associated with a single key. It is comparable to the C++ <a href="http://www.cplusplus.com/reference/map/multimap/">std::multimap</a> class, although it does some things more easily (for instance you can <a href="http://stackoverflow.com/questions/12324807/how-to-avoid-duplicate-pairs-find-a-pair-in-multimap/12325480#12325480">avoid duplicate key-value pairs</a> using <code>AddIfUnique()</code>.)</p>

<p>To use <code>BMultiMap&lt;K, V&gt;</code>, both <code>K</code> and <code>V</code> must be comparable (unlike <code>BDictionary</code> which only needs the key type <code>K</code> to be comparable). This requirement is needed for some methods, such as <code>AddIfUnique</code> and <code>Remove(KeyValuePair&lt;K,V&gt;)</code> (inherited from <code>BList</code>), to work correctly. If you want to use a <code>V</code> that is not actually comparable, you could use a comparison function that pretends all <code>V</code>s are equal (by always returning 0); just be aware that any methods that try to distinguish <code>V</code>s from each other will behave as if they are all equal! You could also sort based on <code>GetHashCode()</code>, just be <strong>very, very careful</strong> to handle the possibility that two <strong>unrelated</strong> objects have the same hashcode (<code>IndexOfExact()</code> sometimes help deal with this case).  </p>

<p><code>BMultiMap</code> provides the illusion that it is a dictionary of sorted collections. The indexer <code>this[K]</code> returns a <code>BMultiMap&lt;K,V&gt;.Values</code> structure, which implements <code>ICollection&lt;V&gt;</code> and provides access to all the values associated with a particular key. To add a new key-value pair, you can either call <code>Add(K, V)</code> on the multimap itself, or <code>this[K].Add(V)</code>. Similarly you can remove all the values for a key using either <code>RemoveAll(k)</code> or <code>this[K].Clear()</code>.<br />
<br />
In reality, <code>BMultiMap</code> is not really a dictionary of collections, it is just a single sorted list. The list is sorted first by key, and then by value, so all the values associated with a particular key <code>k</code> are adjacent to each other in the list. The <code>Values</code> structure calls <code>FindLowerBound</code> and <code>FindUpperBound</code> to figure out where this &quot;sub-list&quot; begins and ends inside the list as a whole.</p>

<p>Please note that the collection returned by <code>this[K]</code> is not indexable; you can't write <code>this[key][0]</code>, for example, although you can of course use <code>this[K].First()</code>, relying on the LINQ extension method <code>First()</code>, and you can use a <code>foreach</code> loop to iterate over the values for a particular key. The <code>Values</code> collection doesn't have an indexer because it would be <em>either</em> incorrect <em>or</em> inefficient. Incorrect, because if it cached the location of the first item to improve performance, this location would change whenever items were added or removed in a different part of the map. On the other hand, if <code>Values</code> does not cache the location of the first item (and it doesn't), a loop like this could be very slow:</p>

<pre>
var values = multimap[key];
for (int i = 0; i &lt; values.Count; i++) {
   DoSomethingWith(values[i]);
} 
</pre>

<p>First of all, measuring the <code>Count</code> requires the multimap to be searched twice: once to find the lower bound (the location where the <code>Values</code> start for the specified <code>key</code>) and once more for the upper bound (where the <code>Values</code> for this <code>key</code> end). And then, because these indexes are not cached, <code>values[i]</code> would have to find the lower bound again, then looking up item at offset <code>i</code> from the lower bound, and finally check to make sure that the key of this item is the same (if not, it would have to throw <code>IndexOutOfRangeException</code>). Since all this work would slow down your code, no indexer is provided. Use a <code>foreach</code> loop instead; the lower bound will be computed only once, before the first iteration of the loop, and the upper bound is not computed (instead, the <code>Values</code> enumerator keeps scanning forward in the B+ tree until the key of the current <code>KeyValuePair</code> changes).  </p>

<p>When calling the indexer <code>this[K]</code>, the specified key does not have to exist in the collection. If it doesn't exist, the indexer returns an empty collection (by the way, do not call <code>this[k].Count</code> unnecessarily; remember, two searches are required to measure the collection's length.) </p>

<p><code>BMultiMap</code> has several methods that you might find useful:</p>

<ul>
	<li><code>FindLowerBound(k)</code>: just like <code>BDictionary</code>'s method by the same name, it finds the first element equal or greater than <code>k</code>. Likewise, <code>FindUpperBound</code> finds the first element greater than <code>k</code>.</li>
	<li><code>FirstIndexOf(k)</code>: like <code>FindLowerBound(k)</code> except that it returns <code>-1</code> if <code>k</code> is not found.</li>
	<li><code>AddIfUnique(k, v)</code>: adds a key-value pair if there is not already a pair that compares equal to the new one. </li>
	<li><code>Remove(k, max)</code>: removes the first <code>max</code> values associated with the specified key</li>
	<li><code>RemoveAny(k)</code>: removes <em>any one</em> pair that has the specified key (it's similar to <code>Remove(k, 1)</code> but runs slightly faster and you can't predict which one it will remove)</li>
	<li><code>RemoveAll(k)</code>: removes all key-value pairs with the specified key. </li>
	<li><code>IndexOfExact(k)</code>, <code>FindLowerBoundExact(k)</code>: finds the index of a value <code>k</code> that not only compares equal using the comparison function, but <em>also</em> compares equal according to <a href="http://msdn.microsoft.com/en-us/library/system.object.equals.aspx"><code>object.Equals</code></a>. This can be useful if the comparison function only sorts based on <em>part</em> of the object, but you'd also like to match the <em>rest</em> of the object that the comparison function ignores.</li>
</ul>

<h2>In Conclusion</h2>

<p>So there you have it, a bunch of sorted data structures.</p>

<p>In terms of performance, I haven't benchmarked any of these data structures, but I can predict with confidence that: </p>

<ul>
	<li>The <code>AList&lt;T&gt;</code> family of data structures is generally slower than <code>List&lt;T&gt;</code> for indexing, enumerating (foreach), adding items at the end, removing items from the end, and any operation involving a short list (less than 20-50 items).  </li>
	<li>The <code>AList&lt;T&gt;</code> family of data structures is generally faster than <code>List&lt;T&gt;</code> for inserting and removing at random locations, merging lists, splitting lists, cloning, etc., for lists that are long.</li>
	<li>The <code>AList&lt;T&gt;</code> family of data structures will generally use slightly more memory than <code>List&lt;T&gt;</code>.  </li>
	<li><code>BDictionary&lt;K,V&gt;</code> is generally much faster than <code>SortedList&lt;K,V&gt;</code> for lists of significant size (above 50 items). <code>BList&lt;T&gt;</code> and <code>BMultiMap&lt;K,V&gt;</code> have similar performance as <code>BDictionary&lt;T&gt;</code>. </li>
	<li><code>BDictionary&lt;K,V&gt;</code> will be slower than <code>Dictionary&lt;K,V&gt;</code> but it will generally use less memory.</li>
	<li>I don't know whether <code>BDictionary&lt;K,V&gt;</code> is faster or slower than <code>SortedDictionary&lt;K,V&gt;</code> but it will definitely use less memory.</li>
	<li><code>BMultiMap&lt;K,V&gt;</code> has the same memory requirements as <code>BDictionary&lt;K,V&gt;</code>, and it will use <em>much</em> less memory than <code>Dictionary&lt;K,List&lt;V&gt;&gt;</code>.  </li>
</ul>

<p>In part 3, I'll talk about the much simpler <code>DList&lt;T&gt;</code> and <code>DListInternal&lt;T&gt;</code> data structures, which are faster than both <code>List&lt;T&gt;</code> and <code><code>AList&lt;T&gt;</code></code> in certain situations.  </p>

<p>The download associated with this article has been refactored into two libraries since the previous article, but it still contains lots of stuff that is not related to ALists. Besides ALists, I've written several other collection classes and various other &quot;utility&quot; libraries--<a href="http://www.codeproject.com/Articles/34753/Symbols-as-extensible-enums">symbols</a>, <a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">VLists</a>, extension methods, that sort of thing--which I'm a bit too busy (lazy?) to strip out right now. I'll try to do better when I get around to Part 3 of the series. For now, <code>Loyc.Essentials.dll</code> contains miscellaneous code, some of it related to my collection classes, some of it unrelated. <code>Loyc.Collections.dll</code> is the main collection of collection classes, including all the <code>AList</code> data structures. There is also a test suite (NUnit-based) which the included <code>Tests.exe</code> program will run.</p>

<p>The projects and solution are for Visual Studio 2010 and currently compile for .NET 4, although there isn't anything in the implementation of the A-Lists that requires version 4 of .NET.  If you adapt A-Lists for .NET 2.0, Silverlight, XNA, etc., feel free to leave a comment about your success.</p>

<h2>History</h2>

<ul>
	<li>March 27, 2013: <a href="http://www.codeproject.com/Articles/568095/The-List-Trifecta-Part-1">Part 1</a> published</li>
	<li>September 8, 2013: Part 2 published</li>
</ul>

<p><a href="http://www.codeproject.com/Articles/612301/The-List-Trifecta-Part">Originally published on CodeProject.</a></p>
